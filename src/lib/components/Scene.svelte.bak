<script lang="ts">
    import { T, useTask } from "@threlte/core";
    import { RigidBody, Collider, AutoColliders } from "@threlte/rapier";
    import { interactivity } from "@threlte/extras";
    import { onMount, onDestroy } from "svelte";
    import type { RigidBody as RapierRigidBody } from "@dimforge/rapier3d-compat";

    import { invoke } from "@tauri-apps/api/core";
    import { listen, type UnlistenFn } from "@tauri-apps/api/event";
    import { playHit, playWall, playGoal } from "$lib/audio";

    let {
        wsConnection,
        isHost,
        isSinglePlayer = false,
    } = $props<{
        wsConnection: any; // unused now
        isHost: boolean;
        isSinglePlayer?: boolean;
    }>();

    interactivity();

    let puckPos = $state([0, 0.5, 0] as [number, number, number]);
    let hostPaddlePos = $state([0, 0.2, 4] as [number, number, number]);
    let clientPaddlePos = $state([0, 0.2, -4] as [number, number, number]);

    let score = $state([0, 0] as [number, number]);

    let puckRigidBody = $state<RapierRigidBody | undefined>();
    let hostPaddleBody = $state<RapierRigidBody | undefined>();
    let clientPaddleBody = $state<RapierRigidBody | undefined>();

    // Track the pointer intersection with the game board
    let pointerTarget = $state({ x: 0, z: 0 });

    // Interpolation Targets for Client
    let targetPuckPos = { x: 0, y: 0.1, z: 0 };
    let targetHostPaddlePos = { x: 0, y: 0.2, z: 4 };

    // Interpolation Targets for Host (receiving client moves)
    let targetClientPaddlePos = { x: 0, y: 0.2, z: -4 };

    let unlisten: UnlistenFn | null = null;
    onMount(async () => {
        pointerTarget = { x: 0, z: isHost ? 4 : -4 };
        unlisten = await listen<[string, string]>(
            "udp-msg-received",
            (event) => {
                try {
                    const msg = JSON.parse(event.payload[1]);
                    if (isHost) {
                        if (msg.type === "input") {
                            targetClientPaddlePos = {
                                x: msg.pos[0],
                                y: 0.2,
                                z: msg.pos[2],
                            };
                        }
                    } else {
                        if (msg.type === "state") {
                            score = msg.score;
                            targetPuckPos = {
                                x: msg.puck[0],
                                y: 0.1,
                                z: msg.puck[2],
                            };
                            targetHostPaddlePos = {
                                x: msg.hostPaddle[0],
                                y: 0.2,
                                z: msg.hostPaddle[2],
                            };

                            if (puckRigidBody) {
                                const curPuck = puckRigidBody.translation();
                                if (Math.abs(curPuck.z - msg.puck[2]) > 2) {
                                    puckRigidBody.setTranslation(
                                        targetPuckPos,
                                        true,
                                    );
                                }
                            }
                        }
                    }
                } catch (e) {}
            },
        );
    });

    // Track puck speed to detect collision impulses
    let prevPuckSpeed = 0;
    // ────────────────────────────────────────────────────────────────────────

    onDestroy(() => {
        if (unlisten) unlisten();
    });

    useTask(() => {
        if (isHost) {
            // Only smoothly interpolate network client paddle if multiplayer
            if (!isSinglePlayer && clientPaddleBody) {
                const currentTranslation = clientPaddleBody.translation();
                clientPaddleBody.setNextKinematicTranslation({
                    x:
                        currentTranslation.x +
                        (targetClientPaddlePos.x - currentTranslation.x) * 0.4,
                    y: 0.2,
                    z:
                        currentTranslation.z +
                        (targetClientPaddlePos.z - currentTranslation.z) * 0.4,
                });
                // Keep visually synced
                clientPaddlePos = [
                    currentTranslation.x,
                    0.2,
                    currentTranslation.z,
                ];
            }

            if (hostPaddleBody) {
                // Spring-driven dynamic movement
                const t = hostPaddleBody.translation();
                // Target position
                const tx = pointerTarget.x;
                const tz = pointerTarget.z;

                // Calculate velocity needed to reach target
                const speedMult = 15.0; // Stiff spring
                const vx = (tx - t.x) * speedMult;
                const vz = (tz - t.z) * speedMult;

                hostPaddleBody.setLinvel({ x: vx, y: 0, z: vz }, true);
                // Keep upright
                hostPaddleBody.setAngvel({ x: 0, y: 0, z: 0 }, true);
                if (Math.abs(t.y - 0.2) > 0.05) {
                    hostPaddleBody.setTranslation(
                        { x: t.x, y: 0.2, z: t.z },
                        true,
                    );
                }
            }

            if (puckRigidBody && hostPaddleBody) {
                const pTrans = puckRigidBody.translation();
                const hTrans = hostPaddleBody.translation();

                // ── Collision sound detection ─────────────────────────────
                const vel = puckRigidBody.linvel();
                const speed = Math.sqrt(vel.x * vel.x + vel.z * vel.z);
                if (speed - prevPuckSpeed > 1.5) {
                    // Speed jumped — paddle or wall hit
                    const dist = Math.hypot(
                        pTrans.x - hTrans.x,
                        pTrans.z - hTrans.z,
                    );
                    if (dist < 1.2) {
                        playHit(); // near host paddle
                    } else {
                        playWall();
                    }
                }
                prevPuckSpeed = speed;

                // ── Puck boundary & stability enforcement ─────────────────
                if (puckRigidBody) {
                    const av = puckRigidBody.angvel();
                    puckRigidBody.setAngvel({ x: 0, y: av.y, z: 0 }, true); // allow spin, kill tilt, WAKE UP

                    const t = puckRigidBody.translation();
                    const v = puckRigidBody.linvel();

                    // Pin Y to table surface
                    let py = t.y;
                    let vy = v.y;
                    if (Math.abs(py - 0.1) > 0.04) {
                        py = 0.1;
                        vy = 0;
                    }

                    // Manual wall bounce — prevents any tunneling regardless of collider thickness
                    const xMax = 2.85; // table half-width (3.2) minus puck radius (0.35)
                    let px = t.x,
                        vx = v.x;
                    if (px < -xMax) {
                        px = -xMax;
                        if (vx < 0) {
                            vx = -vx * 0.85;
                            playWall();
                        }
                    }
                    if (px > xMax) {
                        px = xMax;
                        if (vx > 0) {
                            vx = -vx * 0.85;
                            playWall();
                        }
                    }

                    // Z boundaries only outside goal gap (goal width = 1.3 on each side)
                    const zMax = 4.85; // table half-length (5.2) minus puck radius (0.35)
                    let pz = t.z,
                        vz = v.z;
                    const inGoalGap = Math.abs(px) < 1.3;
                    if (!inGoalGap) {
                        if (pz < -zMax) {
                            pz = -zMax;
                            if (vz < 0) {
                                vz = -vz * 0.85;
                                playWall();
                            }
                        }
                        if (pz > zMax) {
                            pz = zMax;
                            if (vz > 0) {
                                vz = -vz * 0.85;
                                playWall();
                            }
                        }
                    }

                    const moved =
                        Math.abs(px - t.x) > 0.001 ||
                        Math.abs(py - t.y) > 0.001 ||
                        Math.abs(pz - t.z) > 0.001;
                    if (moved) {
                        puckRigidBody.setTranslation(
                            { x: px, y: py, z: pz },
                            true,
                        );
                        puckRigidBody.setLinvel({ x: vx, y: vy, z: vz }, true);
                    }
                }

                // Only broadcast if Multiplayer
                if (!isSinglePlayer) {
                    invoke("host_send_msg", {
                        msg: JSON.stringify({
                            type: "state",
                            puck: [pTrans.x, pTrans.y, pTrans.z],
                            hostPaddle: [hTrans.x, hTrans.y, hTrans.z],
                            score,
                        }),
                    }).catch(() => {});
                } else {
                    // Single Player AI Logic for client paddle (the opponent)
                    if (clientPaddleBody) {
                        const targetX = pTrans.x;
                        const cTrans = clientPaddleBody.translation();

                        // Only track aggressive if puck is moving towards the AI or is on AI's half
                        const puckVelocity = puckRigidBody.linvel();
                        let aiSpeedMultiplier = 0.03;
                        if (pTrans.z < 0 || puckVelocity.z < 0) {
                            aiSpeedMultiplier = 0.08; // move faster when defending
                        }

                        // Clamp AI X to prevent it moving too far off edges
                        let nextX =
                            cTrans.x + (targetX - cTrans.x) * aiSpeedMultiplier;
                        nextX = Math.max(-2.5, Math.min(2.5, nextX));

                        // Track Z but stay in top half
                        let targetZ = Math.min(-0.5, pTrans.z);
                        // If puck is far away, drift back to center defense
                        if (pTrans.z > 0) {
                            targetZ = -4.0;
                        }

                        let nextZ =
                            cTrans.z +
                            (targetZ - cTrans.z) * (aiSpeedMultiplier * 1.5);
                        nextZ = Math.min(-0.5, Math.max(-4.5, nextZ));

                        // Drive AI paddle using velocity (spring) to target
                        const speedMult = 20.0;
                        const vx = (nextX - cTrans.x) * speedMult;
                        const vz = (nextZ - cTrans.z) * speedMult;

                        clientPaddleBody.setLinvel(
                            { x: vx, y: 0, z: vz },
                            true,
                        );
                        clientPaddleBody.setAngvel({ x: 0, y: 0, z: 0 }, true);
                        if (Math.abs(cTrans.y - 0.2) > 0.05) {
                            clientPaddleBody.setTranslation(
                                { x: cTrans.x, y: 0.2, z: cTrans.z },
                                true,
                            );
                        }
                    }
                }

                // Basic Goal Detection
                if (pTrans.z > 5.4) {
                    score[1]++;
                    playGoal();
                    puckRigidBody.setTranslation({ x: 0, y: 0.1, z: 0 }, true);
                    puckRigidBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
                } else if (pTrans.z < -5.4) {
                    score[0]++;
                    playGoal();
                    puckRigidBody.setTranslation({ x: 0, y: 0.1, z: 0 }, true);
                    puckRigidBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
                } else if (pTrans.y < -2) {
                    // Puck fell off the table
                    puckRigidBody.setTranslation({ x: 0, y: 0.1, z: 0 }, true);
                    puckRigidBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
                }
            }
        } else {
            // CLIENT LOGIC
            // Smoothly move client paddle towards local pointer (Velocity Driven)
            if (clientPaddleBody) {
                const t = clientPaddleBody.translation();
                const tx = pointerTarget.x;
                const tz = pointerTarget.z;

                const speedMult = 15.0;
                const vx = (tx - t.x) * speedMult;
                const vz = (tz - t.z) * speedMult;

                clientPaddleBody.setLinvel({ x: vx, y: 0, z: vz }, true);
                clientPaddleBody.setAngvel({ x: 0, y: 0, z: 0 }, true);
                if (Math.abs(t.y - 0.2) > 0.05) {
                    clientPaddleBody.setTranslation(
                        { x: t.x, y: 0.2, z: t.z },
                        true,
                    );
                }

                invoke("client_send_msg", {
                    msg: JSON.stringify({
                        type: "input",
                        pos: [t.x, 0.2, t.z],
                    }),
                }).catch(() => {});
            }

            // Smoothly interpolate remote puck (Interpolation)
            if (puckRigidBody) {
                const currentTranslation = puckRigidBody.translation();
                puckRigidBody.setTranslation(
                    {
                        x:
                            currentTranslation.x +
                            (targetPuckPos.x - currentTranslation.x) * 0.2,
                        y: 0.1,
                        z:
                            currentTranslation.z +
                            (targetPuckPos.z - currentTranslation.z) * 0.2,
                    },
                    true,
                );

                // Keep visually synced — always pin Y to table height
                puckPos = [currentTranslation.x, 0.1, currentTranslation.z];
            }

            // Smoothly interpolate remote host paddle
            if (hostPaddleBody) {
                const t = hostPaddleBody.translation();
                const tx = targetHostPaddlePos.x;
                const tz = targetHostPaddlePos.z;

                const speedMult = 15.0;
                const vx = (tx - t.x) * speedMult;
                const vz = (tz - t.z) * speedMult;

                hostPaddleBody.setLinvel({ x: vx, y: 0, z: vz }, true);
                hostPaddleBody.setAngvel({ x: 0, y: 0, z: 0 }, true);

                hostPaddlePos = [t.x, 0.2, t.z];
            }
        }
    });

    function onPointerMove(e: any) {
        if (e.point) {
            // Restrict movement to own half
            let clampedZ = e.point.z;
            if (isHost) {
                clampedZ = Math.max(0.5, Math.min(4.5, e.point.z));
            } else {
                clampedZ = Math.min(-0.5, Math.max(-4.5, e.point.z));
            }
            pointerTarget = {
                x: Math.max(-2.5, Math.min(2.5, e.point.x)),
                z: clampedZ,
            };
        }
    }
</script>

<T.PerspectiveCamera
    makeDefault={true as any}
    position={[0, 10, isHost ? 10 : -10]}
    oncreate={(ref) => ref.lookAt(0, 0, 0)}
/>

<T.AmbientLight intensity={0.6} />
<T.DirectionalLight position={[5, 10, 5]} intensity={1.5} castShadow />

<!-- Score Display (Simple HTML overlay) -->
<div
    class="absolute top-8 left-0 right-0 pointer-events-none flex justify-center items-start z-10 w-full h-full text-white font-bold text-4xl gap-32"
>
    <div class={!isHost ? "text-emerald-400" : "text-neutral-500"}>
        {score[1]}
    </div>
    <div class={isHost ? "text-blue-400" : "text-neutral-500"}>{score[0]}</div>
</div>

<!-- Interaction Plane -->
<T.Mesh
    visible={false}
    position={[0, 0.5, 0]}
    rotation.x={-Math.PI / 2}
    onpointermove={onPointerMove}
    onpointerdown={onPointerMove}
>
    <T.PlaneGeometry args={[20, 20]} />
    <T.MeshBasicMaterial transparent opacity={0} />
</T.Mesh>

<!-- Table -->
<RigidBody type="fixed">
    <T.Group position={[0, -0.1, 0]}>
        <!-- Extend floor collider width (8.0 total) so it perfectly goes UNDER the walls -->
        <Collider shape="cuboid" args={[4.0, 0.1, 5.2]} />
        <!-- Floor Visual -->
        <T.Mesh receiveShadow>
            <T.BoxGeometry args={[6.4, 0.2, 10.4]} />
            <T.MeshStandardMaterial
                color="#3b82f6"
                roughness={0.2}
                metalness={0.1}
            />
        </T.Mesh>
    </T.Group>

    <!-- Visual Walls and Colliders -->
    <!-- Left Wall -->
    <T.Group position={[-3.3, 0.2, 0]}>
        <Collider
            shape="cuboid"
            args={[0.5, 0.3, 5.4]}
            restitution={0.9}
            friction={0}
        />
        <T.Mesh castShadow receiveShadow>
            <T.BoxGeometry args={[0.2, 0.4, 10.8]} />
            <T.MeshStandardMaterial color="#94a3b8" />
        </T.Mesh>
    </T.Group>

    <!-- Right Wall -->
    <T.Group position={[3.3, 0.2, 0]}>
        <Collider
            shape="cuboid"
            args={[0.5, 0.3, 5.4]}
            restitution={0.9}
            friction={0}
        />
        <T.Mesh castShadow receiveShadow>
            <T.BoxGeometry args={[0.2, 0.4, 10.8]} />
            <T.MeshStandardMaterial color="#94a3b8" />
        </T.Mesh>
    </T.Group>

    <!-- Top Wall Left (Client side) -->
    <T.Group position={[-2.2, 0.2, -5.3]}>
        <Collider
            shape="cuboid"
            args={[1.0, 0.3, 0.5]}
            restitution={0.9}
            friction={0}
        />
        <T.Mesh castShadow receiveShadow>
            <T.BoxGeometry args={[2.0, 0.4, 0.2]} />
            <T.MeshStandardMaterial color="#94a3b8" />
        </T.Mesh>
    </T.Group>

    <!-- Top Wall Right (Client side) -->
    <T.Group position={[2.2, 0.2, -5.3]}>
        <Collider
            shape="cuboid"
            args={[1.0, 0.3, 0.5]}
            restitution={0.9}
            friction={0}
        />
        <T.Mesh castShadow receiveShadow>
            <T.BoxGeometry args={[2.0, 0.4, 0.2]} />
            <T.MeshStandardMaterial color="#94a3b8" />
        </T.Mesh>
    </T.Group>

    <!-- Bottom Wall Left (Host side) -->
    <T.Group position={[-2.2, 0.2, 5.3]}>
        <Collider
            shape="cuboid"
            args={[1.0, 0.3, 0.5]}
            restitution={0.9}
            friction={0}
        />
        <T.Mesh castShadow receiveShadow>
            <T.BoxGeometry args={[2.0, 0.4, 0.2]} />
            <T.MeshStandardMaterial color="#94a3b8" />
        </T.Mesh>
    </T.Group>

    <!-- Bottom Wall Right (Host side) -->
    <T.Group position={[2.2, 0.2, 5.3]}>
        <Collider
            shape="cuboid"
            args={[1.0, 0.3, 0.5]}
            restitution={0.9}
            friction={0}
        />
        <T.Mesh castShadow receiveShadow>
            <T.BoxGeometry args={[2.0, 0.4, 0.2]} />
            <T.MeshStandardMaterial color="#94a3b8" />
        </T.Mesh>
    </T.Group>
</RigidBody>

<!-- Corner fillets — rounded cylinders that smoothly deflect the puck off corners -->
{#each [[-3.2, 5.2], [3.2, 5.2], [-3.2, -5.2], [3.2, -5.2]] as [cx, cz]}
    <RigidBody type="fixed">
        <T.Group position={[cx, 0.22, cz]}>
            <Collider shape="cylinder" args={[0.22, 0.35]} restitution={0.7} />
            <T.Mesh castShadow>
                <T.CylinderGeometry args={[0.35, 0.35, 0.44, 24]} />
                <T.MeshStandardMaterial color="#64748b" roughness={0.3} />
            </T.Mesh>
        </T.Group>
    </RigidBody>
{/each}

<!-- PUCK -->
<T.Group position={puckPos}>
    <RigidBody
        bind:rigidBody={puckRigidBody}
        type={isHost ? "dynamic" : "kinematicPosition"}
        linearDamping={0.15}
        angularDamping={1}
        canSleep={false}
        ccd={true}
        lockRotations={false}
        enabledTranslations={[true, false, true]}
    >
        <!-- Svelte 5 syntax for Threlte Collider child requires wrapping in a group or direct -->
        <Collider
            shape="cylinder"
            args={[0.1, 0.3]}
            restitution={1.2}
            friction={0}
        />
        <T.Mesh castShadow>
            <T.CylinderGeometry args={[0.3, 0.3, 0.2, 32]} />
            <T.MeshStandardMaterial
                color="#fef08a"
                emissive="#ca8a04"
                emissiveIntensity={0.5}
            />
        </T.Mesh>
    </RigidBody>
</T.Group>

<!-- HOST PADDLE -->
<T.Group position={hostPaddlePos}>
    <RigidBody
        bind:rigidBody={hostPaddleBody}
        type="dynamic"
        ccd={true}
        lockRotations={true}
    >
        <Collider
            shape="cylinder"
            args={[0.2, 0.4]}
            restitution={0.5}
            friction={0}
        />
        <T.Mesh castShadow>
            <T.CylinderGeometry args={[0.4, 0.4, 0.4, 32]} />
            <T.MeshStandardMaterial color="#60a5fa" />
        </T.Mesh>
    </RigidBody>
</T.Group>

<!-- CLIENT PADDLE -->
<T.Group position={clientPaddlePos}>
    <RigidBody
        bind:rigidBody={clientPaddleBody}
        type={isHost && !isSinglePlayer ? "kinematicPosition" : "dynamic"}
        ccd={true}
        lockRotations={true}
    >
        <Collider
            shape="cylinder"
            args={[0.2, 0.4]}
            restitution={0.5}
            friction={0}
        />
        <T.Mesh castShadow>
            <T.CylinderGeometry args={[0.4, 0.4, 0.4, 32]} />
            <T.MeshStandardMaterial color="#34d399" />
        </T.Mesh>
    </RigidBody>
</T.Group>
